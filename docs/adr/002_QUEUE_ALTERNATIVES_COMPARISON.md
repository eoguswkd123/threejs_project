# ADR-002: Queue 대안 비교 분석

> **Version**: 0.0.1
> **Last Updated**: 2025-12-04

## 상태

**초안 (Draft)** | 날짜: 2025-12-04

> **관련 문서**
>
> - [파일 업로드 아키텍처](../fileUpload/FILE_UPLOAD_ARCHITECTURE.md)
> - [구현 체크리스트](../fileUpload/FILE_UPLOAD_CHECKLIST.md)

---

## 목차

1. [핵심 질문](#1-핵심-질문)
2. [프로젝트 컨텍스트](#2-프로젝트-컨텍스트)
3. [대안 목록](#3-대안-목록)
4. [평가 기준](#4-평가-기준)
5. [전문가 분석 종합](#5-전문가-분석-종합)
6. [대안별 상세 분석](#6-대안별-상세-분석)
7. [왜 반드시 Queue여야 하는가?](#7-왜-반드시-queue여야-하는가)
8. [최종 권장사항](#8-최종-권장사항)

---

## 1. 핵심 질문

> **"왜 반드시 Queue여야 하는가? 다른 대안들은 왜 안 되는가?"**

### 권장안 (검토 중)

**RabbitMQ 기반 Message Queue 권장** (단계적 접근: MVP는 DB Polling → 프로덕션은 RabbitMQ)

| 방식              | 적합한 상황                  | 부적합한 상황               |
| ----------------- | ---------------------------- | --------------------------- |
| **Direct HTTP**   | < 1초 작업, 단일 Worker      | PDF 18초 처리, 동시 요청 多 |
| **DB Polling**    | MVP, 일일 작업 <100개        | 확장 필요, 실시간 처리      |
| **Redis Pub/Sub** | 알림, 로깅 (손실 허용)       | 파일 처리 (유실 불가)       |
| **RabbitMQ**      | Long-running, 확장 필요      | 단순 MVP                    |
| **Kafka**         | 10,000+ msg/sec, 이벤트 소싱 | 소규모 팀, 단순 작업 큐     |

---

## 2. 프로젝트 컨텍스트

| 항목      | 값                            | 의미                  |
| --------- | ----------------------------- | --------------------- |
| 처리 시간 | DXF ~2초, PDF ~18초           | **Long-running task** |
| 파일 크기 | 최대 500MB                    | 대용량 처리 필요      |
| 환경      | 키오스크 다수 배포            | **동시 요청 발생**    |
| 팀 규모   | 2-3명                         | 운영 복잡도 제한      |
| Backend   | Spring Boot (Java)            | Spring 생태계 활용    |
| Worker    | Python (ezdxf, PyMuPDF, YOLO) | ML 파이프라인         |

---

## 3. 대안 목록

| #   | 대안                 | 설명                                | 대표 기술                      |
| --- | -------------------- | ----------------------------------- | ------------------------------ |
| 1   | **Direct HTTP**      | Backend → Worker REST API 직접 호출 | RestTemplate, WebClient        |
| 2   | **Database Polling** | DB를 Queue처럼 사용                 | PostgreSQL + SELECT FOR UPDATE |
| 3   | **Redis Pub/Sub**    | Redis 메시지 브로커                 | Spring Data Redis              |
| 4   | **RabbitMQ**         | 전용 Message Queue                  | Spring AMQP                    |
| 5   | **Kafka**            | 이벤트 스트리밍 플랫폼              | Spring Kafka                   |
| 6   | **gRPC Streaming**   | 양방향 스트리밍 RPC                 | grpc-spring-boot-starter       |

---

## 4. 평가 기준

### 4.1 아키텍처 관점

| 기준                            | 설명                                  | 가중치    |
| ------------------------------- | ------------------------------------- | --------- |
| **결합도 (Coupling)**           | 서비스 간 의존성 수준                 | 높음      |
| **장애 격리 (Fault Isolation)** | 한 컴포넌트 장애가 전체에 미치는 영향 | 높음      |
| **확장성 (Scalability)**        | Worker 수평 확장 용이성               | 높음      |
| **신뢰성 (Reliability)**        | 메시지 유실 방지 메커니즘             | 매우 높음 |

### 4.2 구현 관점

| 기준                   | 설명                           | 가중치 |
| ---------------------- | ------------------------------ | ------ |
| **구현 복잡도**        | Spring Boot에서 구현 난이도    | 중간   |
| **트랜잭션 처리**      | DB 저장과 메시지 발행의 원자성 | 높음   |
| **에러 처리**          | 재시도, DLQ, 타임아웃 처리     | 높음   |
| **Spring 생태계 지원** | 공식 스타터, 문서 품질         | 중간   |

### 4.3 운영 관점

| 기준              | 설명                       | 가중치 |
| ----------------- | -------------------------- | ------ |
| **인프라 비용**   | 서버, 메모리, 스토리지     | 중간   |
| **운영 복잡도**   | 설정, 모니터링, 장애 대응  | 높음   |
| **고가용성 (HA)** | 클러스터링, 복제, 페일오버 | 중간   |
| **모니터링**      | 메트릭, 로깅, 알림 설정    | 중간   |

---

## 5. 전문가 분석 종합

### 5.1 시스템 아키텍트 관점

| 대안          | 결합도     | 장애 격리  | 확장성     | 운영 복잡도 | 판정            |
| ------------- | ---------- | ---------- | ---------- | ----------- | --------------- |
| **RabbitMQ**  | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐      | ✅ **권장**     |
| Direct HTTP   | ⭐         | ⭐         | ⭐⭐       | ⭐⭐⭐⭐    | ❌ 부적합       |
| DB Polling    | ⭐⭐       | ⭐⭐       | ⭐         | ⭐⭐⭐⭐    | ⚠️ MVP만        |
| Redis Pub/Sub | ⭐⭐⭐⭐   | ⭐         | ⭐⭐⭐⭐   | ⭐⭐⭐⭐    | ❌ 메시지 손실  |
| Kafka         | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐        | ⚠️ 과잉         |
| gRPC          | ⭐⭐       | ⭐⭐       | ⭐⭐⭐     | ⭐⭐⭐      | ❌ 큐 이점 없음 |

**핵심 인사이트**:

> "10x 성장 시나리오(10→100 키오스크)에서 RabbitMQ만 자연스럽게 확장. Direct HTTP는 Thread Pool 고갈, DB Polling은 쿼리 폭증."

### 5.2 백엔드 아키텍트 관점

| 대안          | 구현 복잡도 | 트랜잭션 처리         | 에러 처리  | Spring 지원 | 판정             |
| ------------- | ----------- | --------------------- | ---------- | ----------- | ---------------- |
| **RabbitMQ**  | ⭐⭐⭐      | ✅ Publisher Confirms | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐  | ✅ **최적**      |
| Direct HTTP   | ⭐⭐        | ❌ 불가능             | ⭐⭐       | ⭐⭐⭐⭐⭐  | ❌ 타임아웃      |
| DB Polling    | ⭐⭐        | ✅ 완벽               | ⭐⭐⭐     | ⭐⭐⭐⭐⭐  | ⚠️ 조건부        |
| Redis Pub/Sub | ⭐⭐⭐      | ❌ 없음               | ⭐⭐       | ⭐⭐⭐⭐    | ❌ 트랜잭션 없음 |
| Kafka         | ⭐⭐⭐⭐    | ✅ Transactional      | ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐  | ⚠️ 과도함        |
| gRPC          | ⭐⭐⭐⭐⭐  | ❌ 복잡               | ⭐⭐       | ⭐⭐⭐      | ❌ 복잡          |

**핵심 인사이트**:

> "Spring AMQP Publisher Confirms로 DB 저장 + 메시지 발행 원자성 보장. `@Transactional` 어노테이션만으로 구현 가능."

### 5.3 DevOps 아키텍트 관점

| 대안          | 월간 비용 | 운영 복잡도 | HA 점수 | 모니터링 | 2-3명 팀 적합도 |
| ------------- | --------- | ----------- | ------- | -------- | --------------- |
| **RabbitMQ**  | $30-150   | 5.0/10      | 9/10    | 9/10     | ✅ 높음         |
| Direct HTTP   | $0        | 5.0/10      | 3/10    | 4/10     | ⚠️ 낮음         |
| DB Polling    | $0        | 4.5/10      | 7/10    | 6/10     | ✅ 높음         |
| Redis Pub/Sub | $20-40    | 5.3/10      | 4/10    | 5/10     | ⚠️ 중간         |
| Kafka         | $200-400  | 8.3/10      | 10/10   | 8/10     | ❌ 낮음         |

**핵심 인사이트**:

> "2-3명 소규모 팀에는 단계적 접근 권장. MVP는 DB Polling으로 빠르게, 프로덕션은 RabbitMQ로 안정성 확보."

---

## 6. 대안별 상세 분석

### 6.1 Direct HTTP ❌ 부적합

```
사용자 → Backend → Worker (18초 대기) → 응답
              ↑
        HTTP Timeout (30초 기본)
        Thread Blocking
        연쇄 장애 위험
```

**치명적 문제**:

| 문제            | 영향                                   |
| --------------- | -------------------------------------- |
| HTTP 타임아웃   | 18초 처리 중 연결 끊김 위험            |
| Thread Blocking | Backend Worker Pool 고갈               |
| 연쇄 장애       | Worker 다운 → Backend 장애 전파        |
| 확장 어려움     | Load Balancer + Service Discovery 필요 |

**적합한 경우**: 처리 시간 <1초, 단일 Worker, 개발/테스트 환경

---

### 6.2 Database Polling ⚠️ MVP용

```
사용자 → Backend → DB (INSERT job)
                    ↑
Worker ← (SELECT ... FOR UPDATE) ← 폴링
```

**장점**:

| 장점             | 설명                        |
| ---------------- | --------------------------- |
| 추가 인프라 없음 | 기존 PostgreSQL 활용        |
| 트랜잭션 보장    | DB 트랜잭션으로 원자성 확보 |
| 디버깅 용이      | SQL 쿼리로 상태 확인        |
| 비용 $0          | 추가 인프라 비용 없음       |

**단점**:

| 단점          | 설명                           |
| ------------- | ------------------------------ |
| 폴링 오버헤드 | 지속적인 SELECT 쿼리 부하      |
| 락 경합       | 다중 Worker 시 FOR UPDATE 경합 |
| 확장성 제한   | Worker↑ → DB 부하↑ (비선형)    |
| 지연 발생     | 폴링 주기만큼 처리 지연        |

**적합한 경우**: MVP, 일일 작업 <100개, 예산 제약

---

### 6.3 Redis Pub/Sub ❌ 메시지 손실 위험

```
Backend → Redis (PUBLISH) → Worker (SUBSCRIBE)
              ↓
         Fire-and-Forget
         메시지 손실 위험!
```

**치명적 문제**:

| 문제          | 영향                             |
| ------------- | -------------------------------- |
| 메시지 휘발성 | Worker 재시작 시 메시지 손실     |
| ACK 없음      | 처리 완료 확인 불가              |
| DLQ 없음      | 실패 작업 추적 불가              |
| 복구 불가     | 500MB 파일 유실 시 재업로드 필요 |

**적합한 경우**: 실시간 알림 (손실 허용), 로깅 (best-effort)

> **참고**: Redis Streams는 다른 기능으로, 지속성을 제공하여 대안이 될 수 있음

---

### 6.4 RabbitMQ ✅ 권장

```
Backend → RabbitMQ → Worker
           ↓           ↓
    메시지 지속성    ACK/NACK
    Dead Letter Q   자동 재시도
```

**핵심 강점**:

| 강점          | 설명                                     |
| ------------- | ---------------------------------------- |
| 메시지 내구성 | 디스크 저장, Broker 재시작 후 복구       |
| ACK 메커니즘  | 처리 완료 확인, 미확인 시 재전달         |
| DLQ           | 실패 작업 격리, 수동 재처리 가능         |
| Spring AMQP   | `@RabbitListener`로 간단한 Consumer 구현 |
| 모니터링      | 내장 Management UI, Prometheus 연동      |
| 적정 복잡도   | 기능 완성도 높으면서 운영 가능           |

**Spring Boot 설정 예시**:

```yaml
spring:
    rabbitmq:
        host: localhost
        port: 5672
        listener:
            simple:
                retry:
                    enabled: true
                    max-attempts: 3
                    initial-interval: 2000
                    multiplier: 2.0
```

#### Python Worker 호환성 ✅

**Pika 라이브러리** (공식 RabbitMQ Python 클라이언트)

| 항목               | 평가       | 설명                                 |
| ------------------ | ---------- | ------------------------------------ |
| 라이브러리 성숙도  | ⭐⭐⭐⭐⭐ | RabbitMQ 공식 지원, 10년+ 역사       |
| 문서 품질          | ⭐⭐⭐⭐   | 공식 튜토리얼, 예제 풍부             |
| ML 라이브러리 호환 | ⭐⭐⭐⭐⭐ | ezdxf, PyMuPDF, YOLO와 충돌 없음     |
| 비동기 지원        | ⭐⭐⭐⭐   | asyncio 지원 (pika.adapters.asyncio) |
| 설치 용이성        | ⭐⭐⭐⭐⭐ | `pip install pika`                   |

**Python Worker 코드 예시**:

```python
import pika
import json

def callback(ch, method, properties, body):
    task = json.loads(body)
    # 파일 처리 로직 (ezdxf, PyMuPDF, YOLO 등)
    process_file(task['file_path'])
    ch.basic_ack(delivery_tag=method.delivery_tag)

connection = pika.BlockingConnection(
    pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.basic_qos(prefetch_count=1)  # Worker당 1개씩 처리
channel.basic_consume(queue='file_queue', on_message_callback=callback)
channel.start_consuming()
```

**Python 라이브러리 비교**:

| 라이브러리   | 용도        | 장단점                                            |
| ------------ | ----------- | ------------------------------------------------- |
| **Pika**     | 범용        | 공식, 안정적, 블로킹/비동기 모두 지원             |
| **Celery**   | 태스크 큐   | 추상화 높음, RabbitMQ 외 백엔드도 지원, 설정 복잡 |
| **aio-pika** | 비동기 전용 | asyncio 네이티브, Pika 래퍼                       |

**권장**: Long-running 처리(18초)이므로 **Pika + BlockingConnection** (간단, 안정적, 디버깅 용이)

---

### 6.5 Kafka ⚠️ 과잉

```
Backend → Kafka (3+ Brokers + ZooKeeper) → Worker
                    ↓
            초당 수백만 메시지 처리 가능
            이벤트 소싱, 메시지 리플레이
            BUT: 2-3명 팀에 과도한 복잡도
```

**문제점**:

| 문제        | 설명                                  |
| ----------- | ------------------------------------- |
| 처리량 낭비 | 처리 시간(18초) >> 메시지 전달(<10ms) |
| 인프라 복잡 | ZooKeeper/KRaft + 3노드 클러스터      |
| 운영 부담   | 파티션 관리, 리밸런싱, ISR 모니터링   |
| 비용        | 월 $200-400 (RabbitMQ 대비 2-10배)    |

**적합한 경우**: 초당 10,000+ 메시지, 이벤트 소싱, 메시지 리플레이 필요

---

### 6.6 gRPC Streaming ❌ 큐 이점 없음

**문제점**:

| 문제             | 설명                                            |
| ---------------- | ----------------------------------------------- |
| 내장 Queue 없음  | 버퍼링/재시도 직접 구현 필요                    |
| 연결 상태 관리   | Long-lived connection 유지 복잡                 |
| Spring 지원 미흡 | 공식 스타터 없음, grpc-spring-boot-starter 사용 |
| 구현 복잡도      | ~280 lines (RabbitMQ ~90 lines 대비)            |

---

## 7. 왜 반드시 Queue여야 하는가?

### 7.1 시간적 분리 (Temporal Decoupling)

```
Direct HTTP:
├─ Backend Thread: ████████████████████ 18초 Blocked ████████████████████
└─ 사용자 대기: 18초+ (타임아웃 위험)

Queue 기반:
├─ Backend Thread: ██ 0.01초 (메시지 발행)
├─ 즉시 job_id 반환
└─ Worker: 독립적으로 18초 처리
```

**결론**: 18초 처리에 HTTP 연결 유지는 불가능 → **Queue 필수**

### 7.2 장애 격리 (Fault Isolation)

| 시나리오       | Direct HTTP                 | Queue 기반                |
| -------------- | --------------------------- | ------------------------- |
| Worker 다운    | Backend 타임아웃, 연쇄 장애 | 메시지 보존, Backend 정상 |
| Worker 재시작  | 처리 중 작업 유실           | 자동 재전달, 유실 없음    |
| 동시 요청 폭주 | Thread Pool 고갈            | Queue가 버퍼 역할         |

**결론**: Worker 장애가 Backend로 전파되면 안 됨 → **Queue 필수**

### 7.3 확장성 (Scalability)

```
10개 키오스크 → 100개 키오스크 성장 시:

Direct HTTP:
├─ Backend Thread Pool 증설
├─ Load Balancer 설정
├─ Service Discovery 구현
└─ 복잡도: 높음

Queue 기반:
├─ Worker 인스턴스 추가
├─ Queue가 자동 분산
└─ 코드 변경: 없음
```

**결론**: 수평 확장이 코드 변경 없이 가능해야 함 → **Queue 필수**

### 7.4 신뢰성 (Reliability)

| 메커니즘          | Redis Pub/Sub    | RabbitMQ          |
| ----------------- | ---------------- | ----------------- |
| 메시지 지속성     | ❌ 없음 (휘발성) | ✅ 디스크 저장    |
| ACK 메커니즘      | ❌ 없음          | ✅ 처리 완료 확인 |
| Dead Letter Queue | ❌ 없음          | ✅ 실패 작업 격리 |
| 재시도            | ❌ 수동 구현     | ✅ 자동 재전달    |

**결론**: 500MB 파일 처리 유실은 치명적 → **신뢰성 있는 Queue 필수**

---

## 8. 최종 권장사항

### 8.1 의사결정 매트릭스

| 기준          | 가중치 | RabbitMQ | DB Polling | Kafka    |
| ------------- | ------ | -------- | ---------- | -------- |
| 신뢰성        | 30%    | 9        | 7          | 10       |
| 확장성        | 25%    | 9        | 4          | 10       |
| 운영 복잡도   | 20%    | 6        | 8          | 3        |
| 비용          | 15%    | 7        | 10         | 4        |
| Spring 통합   | 10%    | 10       | 10         | 9        |
| **가중 평균** | 100%   | **7.95** | **7.05**   | **7.35** |

### 8.2 단계적 접근법 (권장)

```
┌─────────────────────────────────────────────────────────┐
│  Phase 1: Database Polling (MVP/검증)                   │
│  ├─ 추가 인프라: 없음                                    │
│  ├─ 구현 시간: 1-2일                                    │
│  ├─ 적합 조건: 일일 작업 <100개                         │
│  └─ 전환 신호: DB CPU >70%, 폴링 지연 불만              │
├─────────────────────────────────────────────────────────┤
│  Phase 2: RabbitMQ (프로덕션)                           │
│  ├─ 추가 인프라: RabbitMQ 단일/클러스터                 │
│  ├─ 마이그레이션: 1주                                   │
│  ├─ 적합 조건: 일일 작업 >100개, 동시성 증가            │
│  └─ ROI: 사용자 경험 + 운영 가시성                      │
└─────────────────────────────────────────────────────────┘
```

### 8.3 핵심 결론

> **"Long-running Task(>5초) + 동시 요청 + 신뢰성 요구 = Queue 필수"**

| 조건             | 현재 프로젝트    | Queue 필요성 |
| ---------------- | ---------------- | ------------ |
| 처리 시간 >5초   | ✅ PDF 18초      | **필수**     |
| 동시 요청 가능   | ✅ 키오스크 다수 | **필수**     |
| 메시지 유실 불가 | ✅ 500MB 파일    | **필수**     |
| 확장 계획        | ✅ 키오스크 증가 | **필수**     |

### 8.4 권장 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           권장 아키텍처                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐              │
│  │   Frontend   │     │   Backend    │     │  RabbitMQ    │              │
│  │   (React)    │────▶│(Spring Boot) │────▶│              │              │
│  │              │     │              │     │  ┌────────┐  │              │
│  └──────────────┘     └───────┬──────┘     │  │  Queue │  │              │
│         │                     │            │  └────┬───┘  │              │
│         │                     │            │       │      │              │
│         │                     ▼            │  ┌────┴───┐  │              │
│         │             ┌──────────────┐     │  │  DLQ   │  │              │
│         │             │  PostgreSQL  │     │  └────────┘  │              │
│         │             │   (상태)     │     └──────┬───────┘              │
│         │             └──────────────┘            │                      │
│         │                     │                   │                      │
│         │             ┌───────┴──────┐            │                      │
│         └────────────▶│   MinIO/S3   │◀───────────┼──────────────────────│
│          (glTF 로드)  │   (파일)     │            │                      │
│                       └──────────────┘            ▼                      │
│                                           ┌──────────────┐               │
│                                           │    Worker    │               │
│                                           │   (Python)   │               │
│                                           └──────────────┘               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 용어 설명

| 용어                        | 설명                                                     |
| --------------------------- | -------------------------------------------------------- |
| **ACK (Acknowledgment)**    | 메시지 처리 완료 확인 신호                               |
| **DLQ (Dead Letter Queue)** | 처리 실패한 메시지를 모아두는 별도 Queue                 |
| **Publisher Confirms**      | 메시지가 Broker에 도달했음을 확인하는 RabbitMQ 기능      |
| **Temporal Decoupling**     | 송신자와 수신자가 동시에 활성화될 필요 없는 설계         |
| **Fault Isolation**         | 한 컴포넌트 장애가 다른 컴포넌트에 영향을 주지 않는 설계 |

---

## Changelog (변경 이력)

| 버전  | 날짜       | 변경 내용                                                                    |
| ----- | ---------- | ---------------------------------------------------------------------------- |
| 0.0.1 | 2025-12-04 | 초기 버전: 6가지 대안 비교 분석, Python Worker 호환성 분석 (Pika 라이브러리) |
